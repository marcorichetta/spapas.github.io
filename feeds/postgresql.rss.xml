<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>/var/</title><link>https://spapas.github.io/</link><description>Various programming stuff</description><lastBuildDate>Tue, 04 Jul 2017 09:05:00 +0300</lastBuildDate><item><title>Automatically create a category table in Postgresql by extracting unique table values</title><link>https://spapas.github.io/2017/07/04/postgresql-auto-create-category-column/</link><description>&lt;p&gt;Recently I was given an &lt;span class="caps"&gt;SQL&lt;/span&gt; table containing some useful data. The problem with that table was that it was was non-properly normalized but was completely flat,
i.e all its columns contained varchar values while, some of them should have instead contained foreign keys to other tables. Here&amp;#8217;s an example of how this
table looked&amp;nbsp;like:&lt;/p&gt;
&lt;table border="1" class="docutils"&gt;
&lt;colgroup&gt;
&lt;col width="14%" /&gt;
&lt;col width="25%" /&gt;
&lt;col width="28%" /&gt;
&lt;col width="33%" /&gt;
&lt;/colgroup&gt;
&lt;thead valign="bottom"&gt;
&lt;tr&gt;&lt;th class="head" colspan="4"&gt;Parts&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;th class="head"&gt;&lt;span class="caps"&gt;ID&lt;/span&gt;&lt;/th&gt;
&lt;th class="head"&gt;Serial&lt;/th&gt;
&lt;th class="head"&gt;Category&lt;/th&gt;
&lt;th class="head"&gt;Manufacturer&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;423431&lt;/td&gt;
&lt;td&gt;Monitor&lt;/td&gt;
&lt;td&gt;&lt;span class="caps"&gt;LG&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;534552&lt;/td&gt;
&lt;td&gt;Monitor&lt;/td&gt;
&lt;td&gt;&lt;span class="caps"&gt;LG&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;435634&lt;/td&gt;
&lt;td&gt;Printer&lt;/td&gt;
&lt;td&gt;&lt;span class="caps"&gt;HP&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;534234&lt;/td&gt;
&lt;td&gt;Printer&lt;/td&gt;
&lt;td&gt;Samsung&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;234212&lt;/td&gt;
&lt;td&gt;Monitor&lt;/td&gt;
&lt;td&gt;Samsung&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;123123&lt;/td&gt;
&lt;td&gt;Monitor&lt;/td&gt;
&lt;td&gt;&lt;span class="caps"&gt;LG&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;The normalized version of this table should have been instead like&amp;nbsp;this:&lt;/p&gt;
&lt;table border="1" class="docutils"&gt;
&lt;colgroup&gt;
&lt;col width="13%" /&gt;
&lt;col width="23%" /&gt;
&lt;col width="28%" /&gt;
&lt;col width="38%" /&gt;
&lt;/colgroup&gt;
&lt;thead valign="bottom"&gt;
&lt;tr&gt;&lt;th class="head" colspan="4"&gt;Parts&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;th class="head"&gt;&lt;span class="caps"&gt;ID&lt;/span&gt;&lt;/th&gt;
&lt;th class="head"&gt;Serial&lt;/th&gt;
&lt;th class="head"&gt;Category_id&lt;/th&gt;
&lt;th class="head"&gt;Manufacturer_id&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;423431&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;534552&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;435634&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;534234&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;234212&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;123123&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;with the following extra tables that contain the category values with proper foreign&amp;nbsp;keys:&lt;/p&gt;
&lt;table border="1" class="docutils"&gt;
&lt;colgroup&gt;
&lt;col width="22%" /&gt;
&lt;col width="78%" /&gt;
&lt;/colgroup&gt;
&lt;thead valign="bottom"&gt;
&lt;tr&gt;&lt;th class="head" colspan="2"&gt;Category&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;th class="head"&gt;&lt;span class="caps"&gt;ID&lt;/span&gt;&lt;/th&gt;
&lt;th class="head"&gt;Name&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;Monitor&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;Printer&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table border="1" class="docutils"&gt;
&lt;colgroup&gt;
&lt;col width="17%" /&gt;
&lt;col width="83%" /&gt;
&lt;/colgroup&gt;
&lt;thead valign="bottom"&gt;
&lt;tr&gt;&lt;th class="head" colspan="2"&gt;Manufacturer&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;th class="head"&gt;&lt;span class="caps"&gt;ID&lt;/span&gt;&lt;/th&gt;
&lt;th class="head"&gt;Name&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;Monitor&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;Printer&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;The normalized version should be used instead of the flat one &lt;a class="reference external" href="http://www.imdb.com/title/tt0057012/quotes?item=qt0454452"&gt;for reasons which at this moment must be all too obvious&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Having such non-normalized tables is also a common problem I experience with Django: When creating a model
I usually define some &lt;tt class="docutils literal"&gt;CharField&lt;/tt&gt;  with pre-defined &lt;tt class="docutils literal"&gt;choices&lt;/tt&gt; which &amp;#8220;will never change&amp;#8221;. Sometime during the
development (if I am lucky) or when the project is live for years I will be informed that the choices need not
only to be changed but must be changed by the users of the site without the need to change the source code! Or
that the choices/categories have properties (beyond their name) that need to be defined and used in the project. Both
of these cases mean that these categories need to be extracted from simple strings to full Django models (i.e get
normalized in their own&amp;nbsp;table)!&lt;/p&gt;
&lt;p&gt;In this post I will present a function written in &lt;span class="caps"&gt;PL&lt;/span&gt;/pgsql that will automatically normalize a column from a
flat table like the previous. Specifically, using the previous example,
if you have a table named &lt;tt class="docutils literal"&gt;part&lt;/tt&gt; that has a non-normalized
column named &lt;tt class="docutils literal"&gt;category&lt;/tt&gt; then when you call &lt;tt class="docutils literal"&gt;select &lt;span class="pre"&gt;export_relation('part',&lt;/span&gt; 'category')&lt;/tt&gt; the following
will&amp;nbsp;happen:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;A new table named &lt;tt class="docutils literal"&gt;part_category&lt;/tt&gt; will be created. This table will contain two columns &lt;tt class="docutils literal"&gt;id&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;name&lt;/tt&gt;, with &lt;tt class="docutils literal"&gt;id&lt;/tt&gt; being the primary key and &lt;tt class="docutils literal"&gt;name&lt;/tt&gt; having a unique constraint. If the table exists it will be dropped and&amp;nbsp;re-ccreated&lt;/li&gt;
&lt;li&gt;A new column named &lt;tt class="docutils literal"&gt;category_id&lt;/tt&gt; will be added to &lt;tt class="docutils literal"&gt;part&lt;/tt&gt;. This column will be a foreign key to the new table &lt;tt class="docutils literal"&gt;part_category&lt;/tt&gt;.&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;For each unique value &lt;tt class="docutils literal"&gt;v&lt;/tt&gt; of &lt;tt class="docutils literal"&gt;category&lt;/tt&gt;:&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;Insert a new record in &lt;tt class="docutils literal"&gt;part_category&lt;/tt&gt; with &lt;tt class="docutils literal"&gt;v&lt;/tt&gt; in the &lt;tt class="docutils literal"&gt;name&lt;/tt&gt; field of the table and save the inserted id to &lt;tt class="docutils literal"&gt;current_id&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;Set &lt;tt class="docutils literal"&gt;current_id&lt;/tt&gt; to &lt;tt class="docutils literal"&gt;category_id&lt;/tt&gt;  to all rows of &lt;tt class="docutils literal"&gt;part&lt;/tt&gt; where &lt;tt class="docutils literal"&gt;category&lt;/tt&gt; has the value of &lt;tt class="docutils literal"&gt;v&lt;/tt&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Before diving in to the &lt;span class="caps"&gt;PL&lt;/span&gt;/pgSQL script that does the above changes to the table I&amp;#8217;d like to notice that I am
not very experienced with &lt;span class="caps"&gt;PL&lt;/span&gt;/pgSQL since I rarerly use it
(I actually avoid writing code in the database) however, because the case I described is ideal for using a database script
I&amp;#8217;ve bitten the bullet and implemented&amp;nbsp;it.&lt;/p&gt;
&lt;p&gt;Beyond it&amp;#8217;s actual functionality, this script can be used as a reference/cookbook for common &lt;span class="caps"&gt;PL&lt;/span&gt;/pgSQL&amp;nbsp;tasks:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Create/define a &lt;span class="caps"&gt;PL&lt;/span&gt;/pgSQL function (stored&amp;nbsp;procedure)&lt;/li&gt;
&lt;li&gt;Declare&amp;nbsp;variables&lt;/li&gt;
&lt;li&gt;Assign values to&amp;nbsp;variables&lt;/li&gt;
&lt;li&gt;Execute &lt;span class="caps"&gt;SQL&lt;/span&gt; commands with variable defined table / column&amp;nbsp;names&lt;/li&gt;
&lt;li&gt;Log process in &lt;span class="caps"&gt;PL&lt;/span&gt;/pgSQL&lt;/li&gt;
&lt;li&gt;Executing code&amp;nbsp;conditionally&lt;/li&gt;
&lt;li&gt;Loop through the rows of a&amp;nbsp;query&lt;/li&gt;
&lt;li&gt;Save the primary key of an inserted&amp;nbsp;row&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The script works however I feel that more experienced &lt;span class="caps"&gt;PL&lt;/span&gt;/pgSQL developers would write things different - if you have any
proposals please comment out and I&amp;#8217;ll be happy to incorporate them to the&amp;nbsp;script.&lt;/p&gt;
&lt;p&gt;Now, let&amp;#8217;s now take a look at the actual&amp;nbsp;script:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;CREATE&lt;/span&gt; &lt;span class="k"&gt;OR&lt;/span&gt; &lt;span class="k"&gt;REPLACE&lt;/span&gt; &lt;span class="k"&gt;FUNCTION&lt;/span&gt; &lt;span class="n"&gt;export_relation&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;table_name&lt;/span&gt; &lt;span class="nb"&gt;varchar&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;column_name&lt;/span&gt; &lt;span class="nb"&gt;varchar&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;RETURNS&lt;/span&gt; &lt;span class="nb"&gt;void&lt;/span&gt; &lt;span class="k"&gt;AS&lt;/span&gt; &lt;span class="s"&gt;$$&lt;/span&gt;
&lt;span class="k"&gt;DECLARE&lt;/span&gt;
    &lt;span class="n"&gt;val&lt;/span&gt; &lt;span class="nb"&gt;varchar&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;res&lt;/span&gt; &lt;span class="nb"&gt;boolean&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;new_table_name&lt;/span&gt; &lt;span class="nb"&gt;varchar&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;new_column_name&lt;/span&gt; &lt;span class="nb"&gt;varchar&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;current_id&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;BEGIN&lt;/span&gt;
    &lt;span class="n"&gt;new_table_name&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="n"&gt;table_name&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;_&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="n"&gt;column_name&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;new_column_name&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="n"&gt;column_name&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;_id&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;execute&lt;/span&gt; &lt;span class="n"&gt;format&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;drop table if exists %s cascade&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;new_table_name&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;execute&lt;/span&gt; &lt;span class="n"&gt;format&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;CREATE TABLE %s (id serial NOT NULL, name character varying(255) NOT NULL, CONSTRAINT %s_pkey PRIMARY KEY (id), CONSTRAINT %s_unique UNIQUE (name))WITH ( OIDS=FALSE)&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;new_table_name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;new_table_name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;new_table_name&lt;/span&gt;
    &lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;execute&lt;/span&gt; &lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;select exists(SELECT column_name  FROM information_schema.columns WHERE table_name=&amp;#39;&amp;#39;%s&amp;#39;&amp;#39; and column_name=&amp;#39;&amp;#39;%s&amp;#39;&amp;#39;) as x&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;table_name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;new_column_name&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;into&lt;/span&gt; &lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;res&lt;/span&gt; &lt;span class="k"&gt;is&lt;/span&gt; &lt;span class="k"&gt;false&lt;/span&gt; &lt;span class="k"&gt;then&lt;/span&gt;
        &lt;span class="k"&gt;raise&lt;/span&gt; &lt;span class="k"&gt;notice&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;Creating colum&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;execute&lt;/span&gt; &lt;span class="n"&gt;format&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;ALTER TABLE %s ADD COLUMN %s integer null&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;table_name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;new_column_name&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;execute&lt;/span&gt; &lt;span class="n"&gt;format&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;ALTER TABLE %s ADD CONSTRAINT fk_%s FOREIGN KEY (%s) REFERENCES %s(id)&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;table_name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;new_column_name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;new_column_name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;new_table_name&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;val&lt;/span&gt; &lt;span class="k"&gt;IN&lt;/span&gt; &lt;span class="k"&gt;execute&lt;/span&gt; &lt;span class="n"&gt;format&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;select %s from %s group by(%s)&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;column_name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;table_name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;column_name&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;LOOP&lt;/span&gt;
        &lt;span class="k"&gt;RAISE&lt;/span&gt; &lt;span class="k"&gt;NOTICE&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;Inserting new value %s ...&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;execute&lt;/span&gt; &lt;span class="n"&gt;format&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;insert into  %s(name) values (&amp;#39;&amp;#39;%s&amp;#39;&amp;#39;) returning id&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;new_table_name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;into&lt;/span&gt; &lt;span class="n"&gt;current_id&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;raise&lt;/span&gt; &lt;span class="k"&gt;notice&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;Created ID %&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;current_id&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;execute&lt;/span&gt; &lt;span class="n"&gt;format&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;update %s set %s = %s where %s = &amp;#39;&amp;#39;%s&amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;table_name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;new_column_name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;current_id&lt;/span&gt; &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;column_name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;val&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;END&lt;/span&gt; &lt;span class="k"&gt;LOOP&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="cm"&gt;/* Uncomment this if you want to drop the flat column&lt;/span&gt;
&lt;span class="cm"&gt;    raise notice &amp;#39;Dropping colmn&amp;#39;;&lt;/span&gt;
&lt;span class="cm"&gt;    execute format (&amp;#39;alter table %s drop column %s&amp;#39;, table_name, column_name);&lt;/span&gt;
&lt;span class="cm"&gt;    */&lt;/span&gt;

&lt;span class="k"&gt;END&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="s"&gt;$$&lt;/span&gt; &lt;span class="k"&gt;LANGUAGE&lt;/span&gt; &lt;span class="n"&gt;plpgsql&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The first line creates or updates the script. You can just copy over this script to an &lt;span class="caps"&gt;SQL&lt;/span&gt; window and run it as many times as you like (making changes
between runs) and the script will be always updated. The function that is created is actually a procedure since it returns &lt;tt class="docutils literal"&gt;void&lt;/tt&gt; and takes two parameters.
The &lt;tt class="docutils literal"&gt;&lt;span class="caps"&gt;DECLARE&lt;/span&gt;&lt;/tt&gt; section that follows contains all the variables that are used in the&amp;nbsp;script:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;val&lt;/tt&gt; is the current value of the category when looping through their&amp;nbsp;values&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;res&lt;/tt&gt; is a boolean variable used for a&amp;nbsp;conditional&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;new_table_name&lt;/tt&gt; is the name of the table that will be&amp;nbsp;created&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;new_column_name&lt;/tt&gt; is the name of the column that will be added to the old&amp;nbsp;table&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;current_id&lt;/tt&gt; is the id of the last inserted value in the new&amp;nbsp;table&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;After the &lt;tt class="docutils literal"&gt;&lt;span class="caps"&gt;BEGIN&lt;/span&gt;&lt;/tt&gt; the actual procedure starts: First the values of &lt;tt class="docutils literal"&gt;new_table_name&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;new_column_name&lt;/tt&gt; are initialized to be used throughout the code and
then the new table is dropped (if exists) and re-created. Noticce the &lt;tt class="docutils literal"&gt;execute format (parameter)&lt;/tt&gt; function that executes the &lt;span class="caps"&gt;SQL&lt;/span&gt; contained in the parameter which
is a string and is constructed using the variables we&amp;#8217;ve defined. The next line checks if the old table has the new column (i.e category_id) and saves
the result in the &lt;tt class="docutils literal"&gt;res&lt;/tt&gt; variable to check if the new column exists and if not add it to the old&amp;nbsp;table.&lt;/p&gt;
&lt;p&gt;A loop enumerating all unique values of the category column of the old table is then executed. Notice that &lt;tt class="docutils literal"&gt;val&lt;/tt&gt; will contain a single value since the &lt;span class="caps"&gt;SQL&lt;/span&gt; that is executed
will return a single column (that&amp;#8217;s why it is declared as varchar). If we returned more than one column from the select the val could be declared as &lt;tt class="docutils literal"&gt;record&lt;/tt&gt; and access its
properties through dot notation (&lt;tt class="docutils literal"&gt;val.prop1&lt;/tt&gt; etc). The value is inserted to the newly created table using a &lt;tt class="docutils literal"&gt;insert into table values () returning id&lt;/tt&gt; &lt;span class="caps"&gt;SQL&lt;/span&gt; syntax
(so that the new id will be returned - this is an insert/select hybrid command) and saved to the &lt;tt class="docutils literal"&gt;current_id&lt;/tt&gt; variable. The &lt;tt class="docutils literal"&gt;current_id&lt;/tt&gt; variable then is used to update
the new column that was added to the old table with the proper foreign key&amp;nbsp;value.&lt;/p&gt;
&lt;p&gt;Notice that I&amp;#8217;ve a commented out code in the end - if you want you can uncomment it and the old (flat) column will be dropped - so in my examply the &lt;tt class="docutils literal"&gt;category&lt;/tt&gt; column will be
removed since I will have &lt;tt class="docutils literal"&gt;category_id&lt;/tt&gt; to find out the name of each category. I recommend to uncomment this and actually drop the column since when you have both &lt;tt class="docutils literal"&gt;category&lt;/tt&gt;
and &lt;tt class="docutils literal"&gt;category_id&lt;/tt&gt; the values of these two columns are going to get out of sync and since you&amp;#8217;ll have duplicate information your table will be even more non-normalized. You can
of course keep the column to make sure that the script works as you want since if the column is not dropped you can easily return to the previous state of the database by
removeing the new table and&amp;nbsp;column.&lt;/p&gt;
&lt;p&gt;To call it just run &lt;tt class="docutils literal"&gt;select &lt;span class="pre"&gt;export_relation('part',&lt;/span&gt; 'category')&lt;/tt&gt; and you should see some debug info in the messages tab. When the script is finished you&amp;#8217;ll have the
&lt;tt class="docutils literal"&gt;part_category&lt;/tt&gt; table and &lt;tt class="docutils literal"&gt;category_id&lt;/tt&gt; column in the &lt;tt class="docutils literal"&gt;part&lt;/tt&gt; table.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Serafeim Papastefanos</dc:creator><pubDate>Tue, 04 Jul 2017 09:05:00 +0300</pubDate><guid isPermaLink="false">tag:spapas.github.io,2017-07-04:2017/07/04/postgresql-auto-create-category-column/</guid><category>postgresql</category><category>plpgsql</category></item><item><title>Getting a logical backup of all databases of your Postgresql server</title><link>https://spapas.github.io/2016/11/02/postgresql-backup/</link><description>&lt;p&gt;In this small post I will present a small bash script that could be used to create logical backups of all the databases in a Postgresql server along
with some other goodies. More specifically, the script&amp;nbsp;will:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Create two files at /tmp to output information (one for debugging and one with info for sending it through email at the&amp;nbsp;end)&lt;/li&gt;
&lt;li&gt;Create a backup directory with the current&amp;nbsp;date&lt;/li&gt;
&lt;li&gt;Create a list of all databases found on the&amp;nbsp;server&lt;/li&gt;
&lt;li&gt;For each database, vacuum and analyze it, backup it, gzip it and put it in the backup&amp;nbsp;directory&lt;/li&gt;
&lt;li&gt;Write info about the backup in the info log&amp;nbsp;file&lt;/li&gt;
&lt;li&gt;Do the same for global&amp;nbsp;objects&lt;/li&gt;
&lt;li&gt;Send an email when the backup is finished with the info&amp;nbsp;log&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Now, in my system I&amp;#8217;m using an external folder at &lt;tt class="docutils literal"&gt;/mnt/backupdb&lt;/tt&gt; to put my backups. You may either use the same technique or connect remotely to a
postgresql database (so you need to change the parameters of &lt;tt class="docutils literal"&gt;vacuumdb&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;pg_dump&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;pg_dumpall&lt;/tt&gt; to define the server and credentials to connect to)
and put the backups to a local&amp;nbsp;disc.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ch"&gt;#!/bin/sh&lt;/span&gt;
&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&amp;quot;&lt;/span&gt; &amp;gt; /tmp/db_backup.log
&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&amp;quot;&lt;/span&gt; &amp;gt; /tmp/db_backup_info.log
&lt;span class="nv"&gt;date_str&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;date +&lt;span class="s2"&gt;&amp;quot;%Y%m%d_%H%M%S&amp;quot;&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;
&lt;span class="nv"&gt;backup_dir&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/mnt/backupdb/pg_backup.&lt;span class="nv"&gt;$date_str&lt;/span&gt;

mkdir &lt;span class="nv"&gt;$backup_dir&lt;/span&gt;
&lt;span class="nb"&gt;pushd&lt;/span&gt; &lt;span class="nv"&gt;$backup_dir&lt;/span&gt; &amp;gt; /dev/null

&lt;span class="nv"&gt;dbs&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;sudo -u postgres psql -Upostgres -lt &lt;span class="p"&gt;|&lt;/span&gt; grep -v : &lt;span class="p"&gt;|&lt;/span&gt; cut -d &lt;span class="se"&gt;\|&lt;/span&gt; -f &lt;span class="m"&gt;1&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; grep -v template &lt;span class="p"&gt;|&lt;/span&gt; grep -v -e &lt;span class="s1"&gt;&amp;#39;^\s*$&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; sed -e &lt;span class="s1"&gt;&amp;#39;s/  *$//&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;|&lt;/span&gt;  tr &lt;span class="s1"&gt;&amp;#39;\n&amp;#39;&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39; &amp;#39;&lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;
&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Will backup: &lt;/span&gt;&lt;span class="nv"&gt;$dbs&lt;/span&gt;&lt;span class="s2"&gt; to &lt;/span&gt;&lt;span class="nv"&gt;$backup_dir&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &amp;gt;&amp;gt; /tmp/db_backup_info.log
&lt;span class="k"&gt;for&lt;/span&gt; db in &lt;span class="nv"&gt;$dbs&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
  &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Starting backup for &lt;/span&gt;&lt;span class="nv"&gt;$db&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &amp;gt;&amp;gt; /tmp/db_backup_info.log
  &lt;span class="nv"&gt;filename&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nv"&gt;$db&lt;/span&gt;.&lt;span class="nv"&gt;$date_str&lt;/span&gt;.sql.gz
  sudo -u postgres vacuumdb --analyze -Upostgres &lt;span class="nv"&gt;$db&lt;/span&gt; &amp;gt;&amp;gt; /tmp/db_backup.log
  sudo -u postgres pg_dump -Upostgres -v &lt;span class="nv"&gt;$db&lt;/span&gt; -F p &lt;span class="m"&gt;2&lt;/span&gt;&amp;gt;&amp;gt; /tmp/db_backup.log &lt;span class="p"&gt;|&lt;/span&gt; gzip &amp;gt; &lt;span class="nv"&gt;$filename&lt;/span&gt;
  &lt;span class="nv"&gt;size&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;stat &lt;span class="nv"&gt;$filename&lt;/span&gt; --printf&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;%s&amp;quot;&lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;
  &lt;span class="nv"&gt;kb_size&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;scale=2; &lt;/span&gt;&lt;span class="nv"&gt;$size&lt;/span&gt;&lt;span class="s2"&gt; / 1024.0&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; bc&lt;span class="sb"&gt;`&lt;/span&gt;
  &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Finished backup for &lt;/span&gt;&lt;span class="nv"&gt;$db&lt;/span&gt;&lt;span class="s2"&gt; - size is &lt;/span&gt;&lt;span class="nv"&gt;$kb_size&lt;/span&gt;&lt;span class="s2"&gt; KB&amp;quot;&lt;/span&gt; &amp;gt;&amp;gt; /tmp/db_backup_info.log
&lt;span class="k"&gt;done&lt;/span&gt;

&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Backing up global objects&amp;quot;&lt;/span&gt; &amp;gt;&amp;gt; /tmp/db_backup_info.log
&lt;span class="nv"&gt;filename&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;global.&lt;span class="nv"&gt;$date_str&lt;/span&gt;.sql.gz
sudo -u postgres pg_dumpall -Upostgres -v -g &lt;span class="m"&gt;2&lt;/span&gt;&amp;gt;&amp;gt; /tmp/db_backup.log &lt;span class="p"&gt;|&lt;/span&gt; gzip &amp;gt; &lt;span class="nv"&gt;$filename&lt;/span&gt;
&lt;span class="nv"&gt;size&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;stat &lt;span class="nv"&gt;$filename&lt;/span&gt; --printf&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;%s&amp;quot;&lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;
&lt;span class="nv"&gt;kb_size&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;scale=2; &lt;/span&gt;&lt;span class="nv"&gt;$size&lt;/span&gt;&lt;span class="s2"&gt; / 1024.0&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; bc&lt;span class="sb"&gt;`&lt;/span&gt;
&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Finished backup for global - size is &lt;/span&gt;&lt;span class="nv"&gt;$kb_size&lt;/span&gt;&lt;span class="s2"&gt; KB&amp;quot;&lt;/span&gt; &amp;gt;&amp;gt; /tmp/db_backup_info.log

&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Ok!&amp;quot;&lt;/span&gt; &amp;gt;&amp;gt; /tmp/db_backup_info.log
mail -s &lt;span class="s2"&gt;&amp;quot;Backup results&amp;quot;&lt;/span&gt; spapas@mymail.foo.bar  &amp;lt; /tmp/db_backup_info.log
&lt;span class="nb"&gt;popd&lt;/span&gt; &amp;gt; /dev/null
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Let&amp;#8217;s explain a bit the above script: The two first lines (echo &amp;#8230;)  will just clear out the two files &lt;tt class="docutils literal"&gt;/tmp/db_backup.log&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;/tmp/db_backup_info.log&lt;/tt&gt;. The first
will contain debug info from the commands and the second one will contain our info that will be sent through an email at the end of the backup. After that, we initialize
&lt;tt class="docutils literal"&gt;date_str&lt;/tt&gt; with the current date in the form &lt;tt class="docutils literal"&gt;20161102_145011&lt;/tt&gt; and the backup_dir with the correct directory to save the backups to. We then create the backup directory
and switch to it with &lt;tt class="docutils literal"&gt;pushd&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;The following, rather long command will assign the names of the databases to the &lt;tt class="docutils literal"&gt;dbs&lt;/tt&gt; variable. So how is it working? &lt;tt class="docutils literal"&gt;psql &lt;span class="pre"&gt;-lt&lt;/span&gt;&lt;/tt&gt; lists the names of the databases, but lists
also more non-needed information which we remove with the following commands (grep, cut etc). The sed removes whitespace and the tr concatenates individual lines to a single line
so dbs will have a value like &amp;#8216;db1 db2 &amp;#8230;&amp;#8217;. For each one of these files then we assign its name and date to a filename and then, after we execute vacuumdb we use pg_dump with gzip to actually
create the backup and output it to the file. The other two lines (size and kb_size) are used to calculate the size of the backup file (to be sure that something is actually created) - you&amp;#8217;ll
need to install bc for that. The same process is followed the to backup global objects (usernames etc) using &lt;tt class="docutils literal"&gt;pg_dumpall &lt;span class="pre"&gt;-g&lt;/span&gt;&lt;/tt&gt;. Finally, we send a mail with a subject of &amp;#8220;Backup results&amp;#8221;
and body the contents of &lt;tt class="docutils literal"&gt;/tmp/db_backup_info.log&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;I&amp;#8217;ve saved this file to &lt;tt class="docutils literal"&gt;/var/lib/pgsql/db_backup_all.sh&lt;/tt&gt;. To run I propose using cron &amp;#8212; just edit your crontab (through &lt;tt class="docutils literal"&gt;vi /etc/crontab&lt;/tt&gt;) and add the&amp;nbsp;line&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
15 2  *  *  * root       /usr/bin/bash /var/lib/pgsql/db_backup_all.sh
&lt;/pre&gt;
&lt;p&gt;This will run the backup every night at 2.15. Uses the root user to have access rights to the backup folder. One thing to be careful about is that on Redhat/Centos distributions,
the above won&amp;#8217;t work because sudo requires a tty to work and cron doesn&amp;#8217;t have one. To fix this, comment out the&amp;nbsp;line&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
Defaults    requiretty
&lt;/pre&gt;
&lt;p&gt;of your /etc/sudoers&amp;nbsp;file.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Update 02/12/2016:&lt;/strong&gt; Here&amp;#8217;s a little better version of the above script&amp;nbsp;that&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Create two files for each database, one with &lt;span class="caps"&gt;SQL&lt;/span&gt; script backup, one with binary backup. Although with &lt;span class="caps"&gt;SQL&lt;/span&gt; backup you can check out the backup and maybe do changes before applying it, the binary backup is a more foolproof method of restoring everything to your database! Also, instead of restoring the database through &lt;tt class="docutils literal"&gt;psql&lt;/tt&gt; (as required by the &lt;span class="caps"&gt;SQL&lt;/span&gt; script backup), using the binary backup you can restore through the &lt;tt class="docutils literal"&gt;pg_restore&lt;/tt&gt; tool.&lt;/li&gt;
&lt;li&gt;Adds a function to output the file size (so the script is more &lt;span class="caps"&gt;DRY&lt;/span&gt;)&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ch"&gt;#!/bin/sh&lt;/span&gt;

&lt;span class="k"&gt;function&lt;/span&gt; output_file_size &lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="nv"&gt;size&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;stat &lt;span class="nv"&gt;$1&lt;/span&gt; --printf&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;%s&amp;quot;&lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;
  &lt;span class="nv"&gt;kb_size&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;scale=2; &lt;/span&gt;&lt;span class="nv"&gt;$size&lt;/span&gt;&lt;span class="s2"&gt; / 1024.0&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; bc&lt;span class="sb"&gt;`&lt;/span&gt;
  &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Finished backup for &lt;/span&gt;&lt;span class="nv"&gt;$2&lt;/span&gt;&lt;span class="s2"&gt; - size is &lt;/span&gt;&lt;span class="nv"&gt;$kb_size&lt;/span&gt;&lt;span class="s2"&gt; KB&amp;quot;&lt;/span&gt; &amp;gt;&amp;gt; /tmp/db_backup_info.log
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&amp;quot;&lt;/span&gt; &amp;gt; /tmp/db_backup.log
&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&amp;quot;&lt;/span&gt; &amp;gt; /tmp/db_backup_info.log
&lt;span class="nv"&gt;date_str&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;date +&lt;span class="s2"&gt;&amp;quot;%Y%m%d_%H%M%S&amp;quot;&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;
&lt;span class="nv"&gt;backup_dir&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/mnt/backupdb/dbpg/pg_backup.&lt;span class="nv"&gt;$date_str&lt;/span&gt;

mkdir &lt;span class="nv"&gt;$backup_dir&lt;/span&gt;
&lt;span class="nb"&gt;pushd&lt;/span&gt; &lt;span class="nv"&gt;$backup_dir&lt;/span&gt; &amp;gt; /dev/null
&lt;span class="nv"&gt;dbs&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;sudo -u postgres psql -Upostgres -lt &lt;span class="p"&gt;|&lt;/span&gt; cut -d &lt;span class="se"&gt;\|&lt;/span&gt; -f &lt;span class="m"&gt;1&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; grep -v template &lt;span class="p"&gt;|&lt;/span&gt; grep -v -e &lt;span class="s1"&gt;&amp;#39;^\s*$&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; sed -e &lt;span class="s1"&gt;&amp;#39;s/  *$//&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;|&lt;/span&gt;  tr &lt;span class="s1"&gt;&amp;#39;\n&amp;#39;&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39; &amp;#39;&lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;
&lt;span class="c1"&gt;#dbs=&amp;#39;dgul  hrms  mailer_server  missions  postgres&amp;#39;&lt;/span&gt;
&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Will backup: &lt;/span&gt;&lt;span class="nv"&gt;$dbs&lt;/span&gt;&lt;span class="s2"&gt; to &lt;/span&gt;&lt;span class="nv"&gt;$backup_dir&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &amp;gt;&amp;gt; /tmp/db_backup_info.log
&lt;span class="k"&gt;for&lt;/span&gt; db in &lt;span class="nv"&gt;$dbs&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
  &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Starting backup for &lt;/span&gt;&lt;span class="nv"&gt;$db&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &amp;gt;&amp;gt; /tmp/db_backup_info.log
  &lt;span class="nv"&gt;filename&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nv"&gt;$db&lt;/span&gt;.&lt;span class="nv"&gt;$date_str&lt;/span&gt;.sql.gz
  &lt;span class="nv"&gt;filename_binary&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nv"&gt;$db&lt;/span&gt;.&lt;span class="nv"&gt;$date_str&lt;/span&gt;.bak.gz
  sudo -u postgres vacuumdb --analyze -Upostgres &lt;span class="nv"&gt;$db&lt;/span&gt; &amp;gt;&amp;gt; /tmp/db_backup.log
  sudo -u postgres pg_dump -Upostgres -v &lt;span class="nv"&gt;$db&lt;/span&gt; -F p &lt;span class="m"&gt;2&lt;/span&gt;&amp;gt;&amp;gt; /tmp/db_backup.log &lt;span class="p"&gt;|&lt;/span&gt; gzip &amp;gt; &lt;span class="nv"&gt;$filename&lt;/span&gt;
  sudo -u postgres pg_dump -Upostgres -v &lt;span class="nv"&gt;$db&lt;/span&gt; -F c &lt;span class="m"&gt;2&lt;/span&gt;&amp;gt;&amp;gt; /tmp/db_backup.log &lt;span class="p"&gt;|&lt;/span&gt; gzip &amp;gt; &lt;span class="nv"&gt;$filename_binary&lt;/span&gt;
  output_file_size &lt;span class="nv"&gt;$filename&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$db&lt;/span&gt;&lt;span class="s2"&gt; sql&amp;quot;&lt;/span&gt;
  output_file_size &lt;span class="nv"&gt;$filename_binary&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$db&lt;/span&gt;&lt;span class="s2"&gt; bin&amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;done&lt;/span&gt;
&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Backing up global objects&amp;quot;&lt;/span&gt; &amp;gt;&amp;gt; /tmp/db_backup_info.log
&lt;span class="nv"&gt;filename&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;global.&lt;span class="nv"&gt;$date_str&lt;/span&gt;.sql.gz
sudo -u postgres pg_dumpall -Upostgres -v -g &lt;span class="m"&gt;2&lt;/span&gt;&amp;gt;&amp;gt; /tmp/db_backup.log &lt;span class="p"&gt;|&lt;/span&gt; gzip &amp;gt; &lt;span class="nv"&gt;$filename&lt;/span&gt;
output_file_size &lt;span class="nv"&gt;$filename&lt;/span&gt; global
&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Ok!&amp;quot;&lt;/span&gt; &amp;gt;&amp;gt; /tmp/db_backup_info.log
mail -s &lt;span class="s2"&gt;&amp;quot;Backup results&amp;quot;&lt;/span&gt; spapas@hcg.gr  &amp;lt; /tmp/db_backup_info.log
&lt;span class="nb"&gt;popd&lt;/span&gt; &amp;gt; /dev/null
&lt;/pre&gt;&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Serafeim Papastefanos</dc:creator><pubDate>Wed, 02 Nov 2016 15:10:00 +0200</pubDate><guid isPermaLink="false">tag:spapas.github.io,2016-11-02:2016/11/02/postgresql-backup/</guid><category>bash</category><category>cron</category><category>postgresql</category></item></channel></rss>